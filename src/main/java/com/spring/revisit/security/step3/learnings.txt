Multiple Beans of SecurityFilterChain:
1) If you have multiple SecurityFilterChain beans, Spring Security requires that they are defined in a way that avoids
ambiguity. This usually means each chain should have specific request patterns (using ant matchers) so that Spring can
determine which chain to use for each incoming request.
2) When you create multiple SecurityFilterChain beans, they should be designed to match different request patterns.
For example:
@Bean
public SecurityFilterChain adminSecurityFilterChain(HttpSecurity http) throws Exception {
    http
        .requestMatchers("/admin/**")
        .authorizeRequests(auth -> auth.anyRequest().hasRole("ADMIN"))
        .and()
        .formLogin();
    return http.build();
}

@Bean
public SecurityFilterChain userSecurityFilterChain(HttpSecurity http) throws Exception {
    http
        .requestMatchers("/user/**")
        .authorizeRequests(auth -> auth.anyRequest().hasRole("USER"))
        .and()
        .formLogin();
    return http.build();
}
In this example, one filter chain is specific to /admin/** requests and another to /user/**, allowing Spring to apply
the appropriate filter chain based on the request.

Understanding @EnableWebSecurity and Order
Multiple Security Configurations: When you have multiple security configuration classes, each marked with
@EnableWebSecurity, they can coexist. The @Order annotation determines the order in which these configurations are
applied. Lower values take precedence.

Default Filter Chain: The default filter chain provided by Spring Security is only applied when there are no custom
SecurityFilterChain beans defined that match the incoming requests.
For class annotated with EnableSecurityConfig annotation, internally WebSecurityConfiguration will be imported as well.
There is a method(springSecurityFilterChain) that will create the Default SpringSecurityFilterChain bean . There we are
checking if filter already exist. If There is a custom springSecurityFilterChain bean already defined then that bean
will be executed and not the default one.

Custom SpringSecurityFilterChain
1) By Default when we are just return httpSecurity.build(), these are the filters that are activated
Security will not be activated as we haven't configured any details.
Security filter chain: [
  DisableEncodeUrlFilter
  WebAsyncManagerIntegrationFilter
  SecurityContextHolderFilter
  HeaderWriterFilter
  CsrfFilter
  LogoutFilter
  RequestCacheAwareFilter
  SecurityContextHolderAwareRequestFilter
  AnonymousAuthenticationFilter
  ExceptionTranslationFilter
]

2)  httpSecurity.authorizeHttpRequests().anyRequest().authenticated()

By Configuring this, one additional filter named as "AuthorizationFilter" is also activated.
Now security is enabled.

Security filter chain: [
  DisableEncodeUrlFilter
  WebAsyncManagerIntegrationFilter
  SecurityContextHolderFilter
  HeaderWriterFilter
  CsrfFilter
  LogoutFilter
  RequestCacheAwareFilter
  SecurityContextHolderAwareRequestFilter
  AnonymousAuthenticationFilter
  ExceptionTranslationFilter
  AuthorizationFilter
]

3) Using:
httpSecurity.authorizeHttpRequests().anyRequest().authenticated().and().formLogin().and().build();

UsernamePasswordAuthenticationFilter, DefaultLoginPageGeneratingFilter, DefaultLogoutPageGeneratingFilter also activated
Security filter chain: [
     DisableEncodeUrlFilter
     WebAsyncManagerIntegrationFilter
     SecurityContextHolderFilter
     HeaderWriterFilter
     CsrfFilter
     LogoutFilter
     UsernamePasswordAuthenticationFilter
     DefaultLoginPageGeneratingFilter
     DefaultLogoutPageGeneratingFilter
     RequestCacheAwareFilter
     SecurityContextHolderAwareRequestFilter
     AnonymousAuthenticationFilter
     ExceptionTranslationFilter
     AuthorizationFilter
   ]

4) For web-based requests we can have the login page generated by DefaultLoginPageGeneratingFilter but for REST Requests
httpSecurity.authorizeHttpRequests().anyRequest().authenticated().and().formLogin().and().httpBasic().and().build();

BasicAuthenticationFilter is also activated now.

Security filter chain: [
  DisableEncodeUrlFilter
  WebAsyncManagerIntegrationFilter
  SecurityContextHolderFilter
  HeaderWriterFilter
  CsrfFilter
  LogoutFilter
  UsernamePasswordAuthenticationFilter
  DefaultLoginPageGeneratingFilter
  DefaultLogoutPageGeneratingFilter
  BasicAuthenticationFilter
  RequestCacheAwareFilter
  SecurityContextHolderAwareRequestFilter
  AnonymousAuthenticationFilter
  ExceptionTranslationFilter
  AuthorizationFilter
]

Authenticated vs PermitAll() vs DenyAll()
1) Authenticated- When configured user has to provide correct authentication details else user will be able to access it
2) PermitAll()- No Authentication is required. Page will be visible to the user.
3) DenyAll() - For a url configured with DenyAll(), user will see the login page(if configured) even after providing the
right credentials user will not be able to access the page

Why mvcHandlerMappingIntrospector bean is required
The mvcHandlerMappingIntrospector plays a central role in the request-handling mechanism of Spring MVC by helping to
manage and resolve handler mappings.
When configuring security at a global level (e.g., using HttpSecurity), the introspector can help ensure that the
defined security settings are applied correctly to the right handler mappings.

Spring provides an input hidden field with csrf token to avoid cross site request forgery Attack.

CSRF(Cross Site Request Forgery) Attack
Suppose for a restaurant website there is an admin user. Once admin is logged-in, they will be able to access all the
pages without logging in again within the same client.
Now a malicious user can potentially build their own form with fields hidden(form may or may not look the same), submit
action going to the exact same url mapping as in the actual restaurant website form and can share that page by some
means and once the admin user clicks on it then the data stored in hidden fields will be executed. Since on submission
the request will go on to the restaurant server and admin user was already logged-in then the server will execute the
logic but the values will be picked up from the hidden form fields.
A malicious user might change the price of specific dishes in their custom form and on submission maybe price of that
dish will get updated in the system and so on.
Similar use-case can be seen in banking and other cases.

Solution:
In Spring, by default, Spring Security's CSRF protection applies to state-changing requests, specifically POST, PUT,
DELETE, and PATCH requests.
Spring will append a hidden field and that will contain in the csrf token for all the forms that we will have in our app

